{"meta":{"title":"江耀祖的blog","subtitle":"努力提高自己才是生活的意义","description":"python golang 互联网 随笔 健身 生活","author":"Jasonjiang","url":"https://Jasonjiang27.github.io/Jasonjiang27.github.io"},"pages":[{"title":"分类","date":"2018-11-13T14:07:06.000Z","updated":"2018-12-08T04:48:26.212Z","comments":false,"path":"categories/index.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-08T04:41:01.000Z","updated":"2018-12-08T04:41:01.573Z","comments":true,"path":"tags/index-1.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-13T14:05:57.000Z","updated":"2018-11-13T14:06:41.336Z","comments":true,"path":"tags/index.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"痛苦可以衡量爱的深浅吗？","slug":"痛苦可以衡量爱的深浅吗？","date":"2021-02-18T14:18:31.000Z","updated":"2021-02-18T14:37:19.387Z","comments":true,"path":"2021/02/18/痛苦可以衡量爱的深浅吗？/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2021/02/18/痛苦可以衡量爱的深浅吗？/","excerpt":"","text":"和心爱的她分手快五个月了，曾经以为，自己狠心一点，大家都会轻松一点，好过一点，却发现现在的自己，真的是太难坚持了，以为曾经的感情问题会影响自己工作，却发现，现在影响更大。以为第一段感情已经是自己的低谷了，现在却发现这是更深的低谷。曾经以为不会再想了，却发现这种阴影仍然挥之不去。 就算是后悔，却不再有后悔的机会，每天都在想你，我失去了一个很爱我的女孩，这种爱恐怕是今生都不再有的爱。 如果能从来，我会认真跟你一起好好沟通，认真和你一起规划未来，认真和你一起享受生活，认真照顾你，认真和你说情话，认真做好每一件事。 如果能从来，我愿意与你一起去小城市生活，让我们的感情不受任何人干扰，我们两个人的生活才是最重要，做着最浪漫的事，和你一起慢慢变老，直到结束这一生~ 我想好好再说一声，我爱你~","categories":[],"tags":[{"name":"情感","slug":"情感","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/情感/"}]},{"title":"hexo常用使用命令&使用指南","slug":"hexo常用使用命令-使用指南","date":"2020-10-21T14:00:57.000Z","updated":"2020-10-21T14:32:08.175Z","comments":true,"path":"2020/10/21/hexo常用使用命令-使用指南/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2020/10/21/hexo常用使用命令-使用指南/","excerpt":"","text":"常用命令以下是常见的hexo命令，在搭建hexo博客中一定会用到。新建一篇博文，默认保存在本地博客目录下的/source/_post文件夹中,并形成一个以name命名的md文件。 $ hexo n &apos;name&apos; 更新博客（生成新的静态博客文件） $ hexo g 预览博客（让博客服务器运行在本地，一般地址为localhost:4000） $ hexo s 部署博客到github等使用命令： $ hexo d 关于各命令的详细用法，在hexo的官方使用文档中有详细的介绍，这里不再赘述。需要注意的是，在配置过程中，_config.yml文件里涉及的选项等需要在选项名冒号后加一个空格再输入项目的值。 为博客添加分类、“关于我”、标签页面等创建分类页面，并且在菜单中显示页面链接1.新建一个页面，命名为categories。命令如下： hexo new page categories 2.编辑刚新建的页面，将页面类型设置为categories，主题会自动为这个页面显示所有分类 title: 分类date: 20xx-xx-xx xx:xx:xx type: “categories”3.在主页菜单中添加链接。编辑主题文件夹中的_config.yml，将menu中的categories: /categories注释去掉即可，如下： menu: home: / categories: /categories archives: /archives tags: /tags 创建”关于我”页面，并且在菜单中显示页面链接1.新建一个about页面 hexo new page &quot;about&quot; 创建标签云页面，并且在菜单中显示页面链接操作方法和以上添加“关于我”及分类页面的操作方式类似，也需要新建页面并且对主题文件夹中的_config.yml文件进行修改。不过，值得注意的是博客文章中添加分类的方式。博客文章中通过修改标题部分的文字来注明这篇博文的所属类别及标签。如： --- title: 使用github结合hexo搭建静态个人博客 date: 2016-9-17 categories: Configuration tags: - github - hexo --- 不同的标签使用代码所示的方法进行分割，也可以使用另一种方法来表示： tags: [github, hexo] 为博客添加搜索引擎收录这里本人使用google搜索收录。首先在google console中添加一个站点，点击界面右上角的添加属性，在弹出窗口中输入博客网站，随后会提示验证网站所有权。采用备用方法：html标记后，在网站首页中添加元标签，点击确认即可进行验证。 此时点击google console，点击网站的标题就可以进入管理页。可以看到侧边栏有一系列菜单，选择抓取中的站点地图，接着选择右侧的添加/测试站点地图，将自己博客中的sitemap.xml文件提交即可完成。 一般添加到google收录后，需要一天才能通过google搜索到网站的相关信息。 为博客添加访问量显示功能由于Next主题中已经集成了多种显示访问量的工具，只需要在原文件中稍稍修改即可。这里本人使用的是不蒜子的网站访问工具。删除掉注释代码后，工具即可使用，如果出现不能使用的情况，将不蒜子官网中的js代码部分添加到主页代码中即可。 转载：常见hexo博客命令用法及博客优化过程","categories":[],"tags":[]},{"title":"练习讲话自信的方法-李开复（转）","slug":"练习讲话自信的方法-李开复（转）","date":"2019-10-14T15:00:20.000Z","updated":"2019-10-14T15:01:47.204Z","comments":true,"path":"2019/10/14/练习讲话自信的方法-李开复（转）/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/10/14/练习讲话自信的方法-李开复（转）/","excerpt":"","text":"自己的老毛病依然困扰自己，需要做一些改变，哪怕是提高一点点也会有很大帮助 1.學習自我肯定：把別人的說三道四擺一旁，肯定自己是獨一無二的，也擁有獨一無二的生命經驗和眼光。 2.爭取機會表達自己的想法：要培養自己的見解、想法，做到有勇氣將自己的思想大聲地表達出來，需要一定的時間不斷練習。用舉手或其他肢體語言讓他人知道你想發言。如果別人都在說話，你感覺插不上話，那就等別人呼吸時把握時機發言。試著從「我有些另外的想法……」開始，不要讓他人打斷你，不要讓他人不理會你的意見。如果你被打斷，你可以理直氣壯地說「請讓我說完」；如果你說了這句話還沒有被理會，重複這句話。 3.不要自動接受別人的看法：理解自己的原則，知道什麼是不可放棄的。絕對不要同意不符合自己原則的事。你可以提出有建設性的、表示反對的意見，在尊重他人的前提下挑戰他們的意見，從而表達你的看法；當然你也要傾聽他人的意見，當別人正確的時候，誠懇地接受他人的意見。要知道：對於任何一件事，每一個人的觀點和想法都可能不一樣。 4.培養表達的技巧：多練習和對方目光接觸，這會讓你慢慢不那麼膽怯，在別人眼裡顯得更有自信。講話時少用拖泥帶水的詞，例如：也許、可能、會不會、如果、聽說等等；多用那些有魄力的詞，例如：我認為、我希望、我要求等等。你也可以去觀摩辯論比賽等活動，學習從不同的立場思考和表達。","categories":[],"tags":[]},{"title":"再一次被扰乱生活，但是我这次我相信我会走出来","slug":"再一次被扰乱生活，但是我这次我相信我会走出来","date":"2019-10-13T11:25:32.000Z","updated":"2019-10-13T11:59:25.945Z","comments":true,"path":"2019/10/13/再一次被扰乱生活，但是我这次我相信我会走出来/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/10/13/再一次被扰乱生活，但是我这次我相信我会走出来/","excerpt":"","text":"再一次，听到了她消息，一样的感觉，心如刀割，或许我自己都不知道为何要心如刀割，想挽回？恨她？怪自己不好？怪自己没用？这些可能都不是，或许也是，心情很复杂，复杂到头痛欲裂，又是一个极本上彻夜未眠的晚上，我这是何苦呢？去打听消息干嘛呢？我不是跟自己说过，不管她消息如何，我都会很难受吗？可又为何没忍住呢？ 曾经的痛苦刻骨铭心，我依然忘不了那种感觉，好在我已经从那种状态走出来了，并且现在的我过的很好，虽然还是单身，但我相信未来我会过得很好。这次的痛苦依然难受，还是需要时间去抚平创伤，但是我知道这次的我已经有了免疫，很快会恢复，会以饱满的热情投入工作中。每一次痛都是一次成长，会让自己变得更好。 或许这次会让我彻底放下，我需要开始新的生活，我需要勇敢主动积极寻找我自己的幸福。努力让自己变得更好，积极面对接受新的人，我相信自己很快或收获自己的幸福。 最后以一句最近看到的话结束，让我觉得很坦然放下的一句话，“一别两宽，各生欢喜”","categories":[],"tags":[]},{"title":"参加中兴社招新员工培训有感","slug":"参加中兴社招新员工培训有感","date":"2019-09-01T03:55:21.000Z","updated":"2019-09-01T04:17:50.755Z","comments":true,"path":"2019/09/01/参加中兴社招新员工培训有感/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/09/01/参加中兴社招新员工培训有感/","excerpt":"","text":"在正式入职三个星期之后，参加了公司的培训，课程主要是企业文化，企业价值观，公司战略，各类合规、安全方面的知识等。课程虽然枯燥，但是这种课堂的氛围却让我回想起曾经校园的生活，同学们坐在一起讨论，讨论方案，吹吹牛，也是很让人愉快的，八十多个人借此机会聚在一起一周的时间，很难得，大家轻松愉快，也让大家结识了不同部门的朋友，大家思维碰撞，互相交流互相提高，很喜欢这种感觉。 不过我依然对于自己在众人面前的表现感到很不满意，我很清楚自己的弱点，自己不敢发言，需要鼓起很大的勇气，自己还是没能战胜自己，同时自己的思维不够活跃。 这也是自己或得不到优秀学员的原因吧，这个社会一定是这样的，你需要自己去争取，不够优秀的自己一定要去争取，适应这个社会，而不是拱手相让。加油吧，一点点感悟，希望自己以后变得更加优秀，多多发表自己的想法，这很重要，另外，多看看书吧，好好学习。","categories":[],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/感悟/"}]},{"title":"leetcode-76-最小覆盖子串","slug":"leetcode-76-最小覆盖子串","date":"2019-07-31T14:48:11.000Z","updated":"2019-07-31T15:24:04.196Z","comments":true,"path":"2019/07/31/leetcode-76-最小覆盖子串/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/07/31/leetcode-76-最小覆盖子串/","excerpt":"","text":"给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。 示例： 输入: S = “ADOBECODEBANC”, T = “ABC”输出: “BANC” 思路： 总的来说，我们希望圈定一个最小的窗口，这个窗口里包含所有t中的字符，并且这个窗口的长度要最短。 所以，我们需要边界指针left,right来去圈定我们窗口的范围。 1.先遍历t中字符串，找到各字符出现个次数，储存在hash中。 2.再遍历s中字符串，每遇到一个t中的字符，则把对应hash value - 1，如果这个字符对应的值大于等于0，则count++。这一段我们的目的是划定一个s中的区间，这个区间包含所有t中字符。count 表示t中有几个字符在s中（当前窗口区间），不包括s中多的重复的字符。 3.当count 第一次等于 t.size()时，说明我们第一次圈定了一个区间，满足所有t中字符在这个区间中都可以找到，但不能保证最短。于是我们更新最短长度，以及最短字符串。接下来我们要右移我们的窗口了，如果我们这个窗口的第一项（也就是要挪动，要移除的那一项）是组成t所需要的，那我们如果要移除掉它，则hash值要加一，因为我们当前窗口接下来不会包含那个字符了，同时count也要根据情况减少，因为count表示s窗口中能找到t的几个字符，现在窗口右移，不包含那个必须组件了，于是要-1。 代码python实现: class Solution: def minWindow(self, s, t): res = &quot;&quot; if len(s) &lt; len(t): return res left = 0 right = 0 min_len = len(s) + 1 m = {} count = 0 for i in t: m[i] = m.get(i,0) + 1#统计t中字符数目 while right &lt; len(s): if s[right] in m: m[s[right]] -= 1 if m[s[right]] &gt;= 0: count += 1 while (count == len(t)): if (right - left + 1 &lt; min_len): min_len = right-left+1 res = s[left:right+1] if s[left] in m: m[s[left]] += 1 if m[s[left]] &gt; 0: count -= 1 left += 1 right += 1 return res 总结： 考虑滑动窗口的方法，获得最小区间的左右指针 参考：https://blog.csdn.net/qq_41231926/article/details/81427851","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/leetcode/"}]},{"title":"近期感悟-找工作、离别和感情问题","slug":"近期感悟-找工作、离别和感情问题","date":"2019-07-13T01:40:33.000Z","updated":"2019-07-13T08:48:47.779Z","comments":true,"path":"2019/07/13/近期感悟-找工作、离别和感情问题/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/07/13/近期感悟-找工作、离别和感情问题/","excerpt":"","text":"最近发生了很多事，有必要写篇文章记录一下，人生总是这样，需要经历才能成长，虽然过程艰辛，但是却一定会有收获，哪怕这种收获是成长、是成熟。 关于找工作 六月初公司（数策）CTO找我谈话，签约到期后不再和我续约，听到这个消息后我其实很淡然，这其中当然有我自身的原因，在这家公司我一直有点不太适应，成长性并不是太好，我自己的学习目标也比较乱，没有专注。当公司做出这个决定的时候，我其实很淡然，尤其知道可以赔偿我一个月工资的时候，我下定决心要入职一家更大的平台。也庆幸有一个月的时间缓冲，我开始准备简历，开始准备面试的问题，开始准备较长的一段辛苦找工作的经历。 其实一开始我还挺有自信的，给自己的目标是golang或者python开发，在拉钩和boss直聘上投了简历之后，立马就有几个面试，之后也陆续收到面试通知，有大厂像360、达观等，也有一些小厂，有游戏服务器开发，也有后端开发，面试形式有的主要考核golang或python基础知识、高级特性，有的考核语言中遇到的一些坑，有的主要考核算法，写代码；有的主要考核简历中的项目，对项目中提问。我总结下来，真正让我觉得难的倒不是语言层面的东西，也不是项目上的，而是一些关于数据库，关于后端设计模式，架构，一些使用到的工具，为什么使用，项目通常都需要考虑的东西，这一块我确实经历的很少，没做过大型项目。导致我面试无数次失败，甚至我一度对自己感到无比失望，开始有点松懈，难以一直保持紧张感，有时候还会玩游戏来缓解一下压力，尤其是6月28号之后，我正式离职了，还是没有拿到offer，这段时间恐怕是我最孤单无助的时候吧，我甚至一度开始怀疑自己是不是不适合做程序猿，我是不是做什么都不行，我是不是适应不了这个社会？可能这种自我怀疑也是男人成长的一部分吧。 正式离职后的两周，我不敢跟外界联系，不敢告诉父母，害怕他们担心，同时也不断有面试机会，我能感受到我的面试表现在不断变好，大多数问题我知道怎么快速应对了，我能感受到我离offer在无限接近，只不过运气还是欠缺一点，但却给了我信心，其实后来我也发现，有时候真的看缘分，变现很好却不给你offer，表现一般甚至不好，但却给你offer了，所以我觉得找工作比找对象还看缘分。 7月5号上午我来到了张江中兴通讯大楼面试，9点半赶到，两轮技术面，一轮HR面，每次都要自我介绍，每次有的问题一样，感到有点心累，其实我觉得我表现一般，第一轮问道我python的装饰器问题，并手写代码，我基本上写出来了，但是也有点问题，第二轮我印象比较深的是关于同步、异步、阻塞、非阻塞问题，我没回答出来，只吞吞吐吐说了一些关于同步异步的区别，这个问题我之前了解过，但是就是表达不好。最后跟HR聊，各方面都会聊，我的经历，我的性格，爱好等等，这个只要老实回答就好。之后让我等通知，三个工作日，我其实对自己的表现不满意，觉得希望不大。等到了下周一，也就是7月8号，我收到HR的电话的录取通知，非常高兴，同时也有另外一个offer，金证股份，给的待遇不错，python开发股票证券交易的策略的。对比了一下，也问了很多人，最终还是决定了去中兴，国企稳定一点，还有做的工作内容对以后发展也更好，这是我考虑的主要原因。 总体来说，过程很艰难，结果很满意，需要做的事还很多，自己还有很多的不足，在数策我已经体会过了，工作中如何学习如何与人打交道都算是有成长吧，下一个目标，下一个旅途将在中兴开启，加油吧，你还需要去证明自己！ 关于离别 人就是这样，是有感情的动物，总是会经历一些离别。来到数策，也算是认识一些朋友，以前以为工作中不会遇到真心朋友了，也确实，相比在学校，社会复杂很多，存在一些为了名利的勾心斗角，都想着升职加薪，这也无可厚非。但我没想到还是遇到一些知心朋友，刘越、陈曦、周鑫等，或许待人真诚才能收获纯真的友谊吧。这段时间也是数策的离职潮，很多人离职，甚至都有离职群了，大家似乎都对公司表达各种各样的不满，所以最近周末也不断有聚餐K歌，大家也都玩的很开心，也喝了很多酒，但是想到有的人一别之后或许永远都不会再见了，这多少让人有点伤感。有时候认识些朋友也不错，但有时候太多的社交也并没有意义，尤其是喝酒，伤身体。 关于感情方面的问题 其实自己一直也想找一个女朋友，但是很多时候会被束缚，自己事业没什么起色，在这方面挺自卑的，作为一个男人意识到这点很难把心思放在追妹子身上。另外，找一个很喜欢的真的很难很难，也不知道是不是我的要求太高，但是一想到两个人在一起就会有各种各样的问题就会害怕在一起。身边也有认识的女生，但是没有觉得适合的，或许是缘分未到吧，或许还在不久的将来才能遇到。","categories":[],"tags":[{"name":"随笔-生活","slug":"随笔-生活","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/随笔-生活/"}]},{"title":"最长回文子串","slug":"最长回文子串","date":"2019-04-01T13:56:24.000Z","updated":"2019-04-01T14:16:07.238Z","comments":true,"path":"2019/04/01/最长回文子串/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/04/01/最长回文子串/","excerpt":"","text":"leetcode第5题给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 思路：将字符串转变为字符数组，通过循环遍历，找出相等的字符，把相等字符作为对列的队头队尾，指针向中间靠拢，一直相等的话就是回文字符串，不相等的话就停止循环遍历。 java代码实现： class Solution { public String longestPalindrome(String s) { if (s.equals(&quot;&quot;)) return &quot;&quot;; char[] cs = s.toCharArray(); int start = 0,end =0; for (int i =0;i&lt;cs.length;i++){ for (int j=0;i-j&gt;end-start;j++){ int m=j,n=i; while(m&lt;n){ if (cs[m] == cs[n]){ m++; n--; }else{ break; } } if (m&gt;=n){ start = j; end = i; } } } return x.substring(start, end+1); } } 最后执行时间178 ms通过，Java提交中击败了22.09% 的用户。之间复杂度应该是O(n2) 暂时没有想到其他方法。","categories":[{"name":"cate","slug":"cate","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/cate/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/随笔/"}]},{"title":"二分查找","slug":"binarySearch","date":"2019-03-31T03:56:24.000Z","updated":"2019-04-01T13:53:23.074Z","comments":true,"path":"2019/03/31/binarySearch/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/03/31/binarySearch/","excerpt":"","text":"实现二分查找二分查找是在排好序的数组中查找指定数字，给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 java 代码实现 public int binarySearch(int[] nums, int key) { int l = 0, h = nums.length - 1; while (l &lt;= h) { int m = l + (h - l) / 2; if (nums[m] == key) { return m; } else if (nums[m] &gt; key) { h = m - 1; } else { l = m + 1; } } return -1; } 此方法是正常实现。每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。","categories":[{"name":"cate","slug":"cate","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/cate/"}],"tags":[{"name":"leetcode算法练习","slug":"leetcode算法练习","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/leetcode算法练习/"}]},{"title":"NLP自然语言处理学习总结","slug":"NLP自然语言处理学习总结","date":"2019-02-22T14:28:48.000Z","updated":"2019-02-23T15:35:09.683Z","comments":true,"path":"2019/02/22/NLP自然语言处理学习总结/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/02/22/NLP自然语言处理学习总结/","excerpt":"","text":"自然语言处理也是目前在人工只能领域 非常获得一个方向，包括智能对话、翻译、语音识别等方向，也是目前人工智能我认为最早能够落地的方向之一吧。 总结一下，大概在如下领域： 信息检索：对大规模文档进行索引。 语音识别：识别包含口语在内的自然语言的声学信号转换成符合预期的信号。 机器翻译：将一种语言翻译成另外一种语言。 智能问答：自动回答问题。 对话系统：通过多回合对话，跟用户进行聊天、回答、完成某项任务。 文本分类：将文本自动归类。 情感分析：判断某段文本的情感倾向 文本生成：根据需求自动生成文本 自动文摘：归纳，总结文本的摘要。 中文分词主要有三种方法： 正向最大匹配法 正向最大匹配法（Maximum Match Method，MM 法）是指从左向右按最大原则与词典里面的词进行匹配。假设词典中最长词是 mm 个字，那么从待切分文本的最左边取 mm 个字符与词典进行匹配，如果匹配成功，则分词。如果匹配不成功，那么取 m−1m−1 个字符与词典匹配，一直取直到成功匹配为止。 例如：句子： 中华民族从此站起来了词典：”中华”，”民族”，”从此”，”站起来了”使用 MM 法分词： 第一步：词典中最长是 4 个字，所以我们将 “中华民族” 取出来与词典进 行匹配，匹配失败。 第二步：于是，去掉 “族”，以 “中华民” 进行匹配，匹配失败 第三步：去掉 “中华民” 中的 “民”，以 “中华” 进行匹配，匹配成功。 第四步：在带切分句子中去掉匹配成功的词，待切分句子变成 “民族从此站起来了”。 第五步：重复上面的第 1 - 4 步骤 第六步：若最后一个词语匹配成功，结束。 最终句子被分成：“中华 / 民族 / 从此 / 站起来了 ” 逆向最大匹配法 逆向最大匹配法（ Reverse Maximum Match Method, RMM 法）的原理与正向法基本相同，唯一不同的就是切分的方向与 MM 法相反。逆向法从文本末端开始匹配，每次用末端的最长词长度个字符进行匹配。 因为基本原理与 MM 法一样，反向来进行匹配就行。所以这里对算法不再赘述。 另外，由于汉语言结构的问题，里面有许多偏正短语，即结构是： 定语 + 中心词（名、代）：（祖国）大地、（一朵）茶花、（前进）的步伐。 状语 + 中心词（动、形）：（很）好看、（独立）思考、（慢慢）地走。 因此，如果采用逆向匹配法，可以适当提高一些精确度。换句话说，使用逆向匹配法要比正向匹配法的误差要小。至于其中的原由，我们不细讲，只做了解即可。 双向匹配法 双向最大匹配法（Bi-direction Matching Method ，BMM）则是将正向匹配法得到的分词结果与逆向匹配法得到的分词结果进行比较，然后按照最大匹配原则，选取次数切分最少的作为结果。 正向最大匹配法，python代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152text = &apos;我们是共产主义的接班人&apos;dic = (&apos;我们&apos;, &apos;是&apos;, &apos;共产主义&apos;, &apos;的&apos;, &apos;接班&apos;, &apos;人&apos;, &apos;你&apos;, &apos;我&apos;, &apos;社会&apos;, &apos;主义&apos;)words = []max_len_word = 0for key in dic: # 若当前词长度大于max_len_word，则将len(key)值赋值给max_len_word if len(key) &gt; max_len_word: max_len_word = len(key)print(max_len_word)# 判断text的长度是否大于0，如果大于0则进行下面的循环while len(text) &gt; 0: # 初始化想要取的字符串长度 # 按照最长词长度初始化 word_len = max_len_word # 对每个字符串可能会有(max_len_word)次循环 for i in range(0, max_len_word): # 令word 等于text的前word_len个字符 word = text[0:word_len] # 为了便于观察过程，我们打印一下当前分割结果 print(&apos;用&apos;, word, &apos;进行匹配&apos;) # 判断word是否在词典dic当中 # 如果不在词典当中 if word not in dic: #则以word_len - 1 word_len -= 1 # 清空word word = [] # 如果word 在词典当中 else: # 更新text串起始位置 text = text[word_len:] # 为了方便观察过程，我们打印一下当前结果 print(&apos;&#123;&#125; 匹配成功，添加进words当中&apos;.format(word)) # 把匹配成功的word添加进上面创建好的words当中 words.append(word) # 清空word word = []print(words) 隐马可夫模型 HMM 应用于分词首先，规定每个字在一个词语当中有着4个不同的位置，词首 B，词中 M，词尾 E，单字成词 S。我们通过给一句话中的每个字标记上述的属性，最后通过标注来确定分词结果。 例如：我今天要去实验室 标注后得到：我/S 今/B 天/E 要/S 去/S 实/B 验/M 室/E 标注序列是：S B E S S B M E 找到 S 、B 、 E 进行切词：S / B E / S / S / B M E / 所以得到的切词结果是：我 / 今天 / 要 / 去 / 实验室 这就是一个 HMM 模型，因为我们要得到每个字的标注信息，但是我们只能看到的是每一个汉字，需要我们通过这些汉字来推断每个字在词中的位置，并且每个字的标注状态还与他前一个字的标注状态有关。 jieba分词 jieba 工具用的 HMM算 法与数据结构算法结合使用的方法，比直接单独使用 HMM 来分词效率高很多，准确率也高很多。 词袋模型和 TF-IDF 模型。这两种模型都可以为我们提取到文本的特征，并将提取的特征用于后续的任务。因此，是文本分类任务当中非常重要的一个环节。 文本分类文本分类技术在自然语言处理领域当中，有着十分重要的地位。一般而言，文本分类是指在一定的规则下，根据内容自动确定文本类别这一过程。文本分类在实际场景中有诸多方面的应用，比如常见的有垃圾邮件分类，情感分析等，新闻分类等等。 按照分类要求的不同，文本分类主要可以分为二分类，多分类，多标签分类三大类。 二分类问题：也是最基础的分类，顾名思义是将文本归为两种类别，比如将正常邮件邮件划分问题，垃圾邮件或者正常邮件。一段影评，判断是好评还是差评的问题。 多分类问题：是将文本划分为多个类别，比如将新闻归为政治类，娱乐类，生活类等等。 多标签分类：是给文本贴上多个不同的标签，比如一部小说可以同时被划分为多个主题，可能既是修仙小说，又是玄幻小说。 两种方法 传统方法：特征提取（也可以叫做特征工程）+ 分类器。就是将文本转换成固定维度的向量，然后送到分类器中进行分类。 深度学习方法：可以自动提取特征，实现端到端的训练，有较强的特征表征能力，所以深度学习进行文本分类的效果往往要好于传统的方法。","categories":[],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/NLP/"}]},{"title":"itchat wxpy的使用总结","slug":"itchat-wxpy的使用总结","date":"2019-02-11T07:55:43.000Z","updated":"2019-02-11T09:25:57.747Z","comments":true,"path":"2019/02/11/itchat-wxpy的使用总结/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/02/11/itchat-wxpy的使用总结/","excerpt":"","text":"最近由于公司项目需要，要实现wx群聊等爬虫功能，故研究了一下python的第三方包itchat和wxpy。发现了很多有趣的功能，由于他们都已封装较好，使用很方便，很少的代码量就可以实现功能。 我主要研究了下如何获取群聊内容，并链接图灵123的API和微软小冰微信公众号实现自动回复。同步群聊内容至其他群。之前也研究过如何获取微信好友的信息，做统计等。事实上，web上的微信内容信息，极本上都可以使用第三方包获取，也就是有些只在移动端上显示的微信消息，才无法通过该方法获取信息。 话不多说直接上代码吧，talk is cheap, show me the code! 获取好友信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# !/usr/bin/env python3# -*- coding:utf-8 -*-import reimport itchatfrom pyecharts import Page, Pie, Map, Bar# 实现获取朋友指定信息的方法def get_key_info(friends_info, key): return list(map(lambda friend_info: friend_info.get(key), friends_info))# 获取朋友的相关信息，生成一个 &#123;key:[value1,value2,...],&#125; 类型的字典，最后返回该字典def get_friends_info(friends): friends_info = dict( sex=get_key_info(friends, &apos;Sex&apos;), # 性别 province=get_key_info(friends, &apos;Province&apos;), # 省份 city=get_key_info(friends, &apos;City&apos;) # 城市 ) return friends_info# 处理数据def count_nums(new_list): new_dict = &#123;&#125; for i in new_list: if bool(re.search(&apos;[a-z]|[A-Z]&apos;, i)): # 如果带英文字母（要么是国外，要么是乱写的）就跳出本次循环 continue elif not new_dict.__contains__(i): new_dict[i] = 1 else: new_dict[i] += 1 new_dict.pop(&apos;&apos;) # 去掉空的键 return new_dict# 画出男女性别比例折线图、朋友省级分布图、城市Top10图def analysis(friends): friends_info = get_friends_info(friends) # 男女性别比例 sex_list = friends_info[&apos;sex&apos;] from collections import Counter sex_dict = dict(Counter(sex_list)) attr = [&quot;未知&quot;, &quot;男性&quot;, &quot;女性&quot;] value = [sex_dict[0], sex_dict[1], sex_dict[2]] page = Page() chart1 = Pie(&quot;微信好友性别比例图&quot;,title_pos=&apos;center&apos;) chart1.add(&quot;&quot;, attr, value, is_label_show=True, legend_orient=&quot;vertical&quot;, legend_pos=&quot;left&quot;) page.add(chart1) # 中国省级分析 province_list = friends_info[&apos;province&apos;] province_dict = count_nums(province_list) attr, value = list(province_dict.keys()), list(province_dict.values()) # 中国省级分析画图 chart2 = Map(&apos;好友省级分布(中国地图)&apos;, width=1200, height=600) chart2.add(&apos;&apos;, attr, value, maptype=&apos;china&apos;, is_label_show=True, is_visualmap=True, visual_text_color=&apos;#000&apos;) page.add(chart2) # 中国城市分析(取前10个人数最多的城市) city_list = friends_info[&apos;city&apos;] city_dict = count_nums(city_list) top_ten_city = dict(sorted(city_dict.items(), key=lambda x: x[1], reverse=True)[0:10]) attr, value = list(top_ten_city.keys()), list(top_ten_city.values()) # 中国城市分析画图 chart3 = Bar(&apos;好友城市分布Top10柱状图&apos;, width=900, height=500) chart3.add(&apos;&apos;, attr, value, is_stack=False,is_label_show=True,bar_category_gap=&apos;20%&apos;) page.add(chart3) page.render(&apos;analysisResult.html&apos;)if __name__ == &apos;__main__&apos;: itchat.auto_login(hotReload=True) friends = itchat.get_friends(update=True) analysis(friends) #itchat.logout() 好友头像拼接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# !/usr/bin/env python3# -*- coding:utf-8 -*-import os, random, mathimport itchatfrom PIL import Image# 实现获取朋友指定信息的方法def get_key_info(friends_info, key): return list(map(lambda friend_info: friend_info.get(key), friends_info))# 获取朋友的相关信息，生成一个 &#123;key:[value1,value2,...],&#125; 类型的字典，最后返回该字典def get_friends_info(friends): friends_info = dict( username=get_key_info(friends, &apos;UserName&apos;), # 用户名 ) return friends_info# 保存微信好友的头像到本地def get_head_img(friends): friends_info = get_friends_info(friends) username = friends_info[&apos;username&apos;] for i, uname in enumerate(username): with open(&quot;headImgs/&quot; + str(i) + &quot;.png&quot;, &quot;wb&quot;) as f: img = itchat.get_head_img(uname) # itchat.get_head_img() 获取到头像二进制，并写入文件，保存每张头像；因为用户名是唯一的，所以根据uname获取头像 f.write(img)# 使用微信好友头像，根据输入的像素值大小，生成一张图片def create_img(): x = 0 y = 0 imgs = os.listdir(&quot;headImgs&quot;) # 返回 headImgs 目录下的文件列表 random.shuffle(imgs) # 将文件列表随机排序 input_length = int(input(&quot;请输入手机屏保长的像素值(一般是两个值中较大的值):&quot;)) input_width = int(input(&quot;请输入手机屏保宽的像素值(一般是两个值中较小的值):&quot;)) new_img = Image.new(&apos;RGBA&apos;, (input_width, input_length)) # 创建 长*宽 的图片用于填充各小图片 width = int(math.sqrt(input_length * input_width / len(imgs))) # 以 长*宽 来拼接图片，math.sqrt()开平方根计算每张小图片的宽高，这里设定每一张小图片还是正方形，虽然存在一点偏差，头像数量越多，壁纸右边和下边的空白越少 num_line = int(input_width / width) # 每行图片数 for i in imgs: #对每一张图片逐个进行处理 try: img = Image.open(&quot;headImgs/&quot; + i) except IOError: print(&quot;第&#123;&#125;张图片为空&quot;.format(i)) #可能会出现某张图片为空的情况 else: img = img.resize((width, width), Image.ANTIALIAS) # 缩小图片 new_img.paste(img, (x * width, y * width)) # 拼接图片，一行排满，换行拼接 x += 1 if x &gt;= num_line: x = 0 y += 1 new_img.save(&quot;mixedImg.png&quot;) itchat.send_image(&apos;mixedImg.png&apos;, toUserName=&apos;filehelper&apos;) #通过文件传输助手发送到自己微信中 #newImg.show()if __name__ == &apos;__main__&apos;: itchat.auto_login(hotReload=True) friends = itchat.get_friends(update=True) get_head_img(friends) create_img() #itchat.logout() 未完。。。 微信群聊多群同步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 # -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Wed Jan 23 20:00:21 2019@author: Jasonjiang&quot;&quot;&quot;import itchatfrom itchat.content import * # 自动回复文本等类别消息# isGroupChat=False表示非群聊消息#@itchat.msg_register([TEXT, MAP, CARD, NOTE, SHARING], isGroupChat=False)#def text_reply(msg): #itchat.send(&apos;这是我的小号，暂无调戏功能，有事请加我大号：Honlann&apos;, msg[&apos;FromUserName&apos;]) # 自动回复图片等类别消息# isGroupChat=False表示非群聊消息#@itchat.msg_register([PICTURE, RECORDING, ATTACHMENT, VIDEO], isGroupChat=False)#def download_files(msg): #itchat.send(&apos;这是我的小号，暂无调戏功能，有事请加我大号：Honlann&apos;, msg[&apos;FromUserName&apos;]) # 自动处理添加好友申请#@itchat.msg_register(FRIENDS)#def add_friend(msg): #itchat.add_friend(**msg[&apos;Text&apos;]) # 该操作会自动将新好友的消息录入，不需要重载通讯录 #itchat.send_msg(u&apos;你好哇&apos;, msg[&apos;RecommendInfo&apos;][&apos;UserName&apos;]) # 自动回复文本等类别的群聊消息# isGroupChat=True表示为群聊消息@itchat.msg_register([TEXT, SHARING], isGroupChat=True)def group_reply_text(msg): # 消息来自于哪个群聊 chatroom_id = msg[&apos;FromUserName&apos;] # 发送者的昵称 username = msg[&apos;ActualNickName&apos;] # 消息并不是来自于需要同步的群 if not chatroom_id in chatroom_ids: return if msg[&apos;Type&apos;] == TEXT: content = msg[&apos;Content&apos;] elif msg[&apos;Type&apos;] == SHARING: content = msg[&apos;Text&apos;] # 根据消息类型转发至其他需要同步消息的群聊 if msg[&apos;Type&apos;] == TEXT: for item in chatrooms: if not item[&apos;UserName&apos;] == chatroom_id: itchat.send(&apos;%s\\n%s&apos; % (username, msg[&apos;Content&apos;]), item[&apos;UserName&apos;]) elif msg[&apos;Type&apos;] == SHARING: for item in chatrooms: if not item[&apos;UserName&apos;] == chatroom_id: itchat.send(&apos;%s\\n%s\\n%s&apos; % (username, msg[&apos;Text&apos;], msg[&apos;Url&apos;]), item[&apos;UserName&apos;]) # 自动回复图片等类别的群聊消息# isGroupChat=True表示为群聊消息 @itchat.msg_register([PICTURE, ATTACHMENT, VIDEO], isGroupChat=True)def group_reply_media(msg): # 消息来自于哪个群聊 chatroom_id = msg[&apos;FromUserName&apos;] # 发送者的昵称 username = msg[&apos;ActualNickName&apos;] # 消息并不是来自于需要同步的群 if not chatroom_id in chatroom_ids: return # 如果为gif图片则不转发 #if msg[&apos;FileName&apos;][-4:] == &apos;.gif&apos;: #return # 下载图片等文件 msg[&apos;Text&apos;](msg[&apos;FileName&apos;]) # 转发至其他需要同步消息的群聊 for item in chatrooms: if not item[&apos;UserName&apos;] == chatroom_id: itchat.send(&apos;@%s@%s&apos; % (&#123;&apos;Picture&apos;: &apos;img&apos;, &apos;Video&apos;: &apos;vid&apos;&#125;.get(msg[&apos;Type&apos;], &apos;fil&apos;), msg[&apos;FileName&apos;]), item[&apos;UserName&apos;]) # 扫二维码登录itchat.auto_login(hotReload=True)# 获取所有通讯录中的群聊# 需要在微信中将需要同步的群聊都保存至通讯录chatrooms = itchat.get_chatrooms(update=True, contactOnly=True)chatroom_ids = [c[&apos;UserName&apos;] for c in chatrooms]print(&apos;正在监测的群聊：&apos;, len(chatrooms), &apos;个&apos;)print(&apos; &apos;.join([item[&apos;NickName&apos;] for item in chatrooms]))# 开始监测itchat.run() 通过微软小冰实现自动回复 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 import itchat# 回复用userIduserId = &apos;&apos;# 获取好友消息@itchat.msg_register([itchat.content.TEXT,itchat.content.PICTURE])def text_reply(msg): # 让小冰回答 global userId userId = msg[&apos;FromUserName&apos;] print(userId) print(getUserNickName(msg)) if getUserNickName(msg) == &quot;宋凡&quot; or getUserNickName(msg) == &quot;寡人有疾&quot;: xbAnswer(msg) print(getUserNickName(msg) + &quot;发来的消息:\\n&quot; + getText(msg))# # 群信息# @itchat.msg_register([itchat.content.TEXT,itchat.content.PICTURE], isGroupChat = True)# def group_reply(msg):# fromUserName = msg[&apos;FromUserName&apos;];# group = itchat.search_chatrooms(userName=fromUserName)# print(msg)# print(group[&apos;NickName&apos;] + &quot;群的 &quot; + msg[&apos;ActualNickName&apos;] + &quot; 发来的消息\\n&quot; + getText(msg) )# # if msg[&apos;isAt&apos;] == True :# global userId# userId = msg[&apos;FromUserName&apos;]# xbAnswer(msg)# # 群信息# @itchat.msg_register(itchat.content.PICTURE, isGroupChat = True)# def group_pic(msg):# msg[&apos;Text&apos;](msg[&apos;FileName&apos;])# itchat.send_image(msg[&apos;FileName&apos;])# 公众号消息@itchat.msg_register([itchat.content.TEXT,itchat.content.PICTURE], isMpChat = True)def map_reply(msg): text = getText(msg) global userId if msg[&apos;Type&apos;] == &apos;Picture&apos;: msg[&apos;Text&apos;](msg[&apos;FileName&apos;]) itchat.send_image(msg[&apos;FileName&apos;],userId) itchat.send_msg(&apos;上图为微软小冰回答&apos;, userId) else: itchat.send_msg(text, userId)# 获取昵称def getUserNickName(msg): fromUserName = msg[&apos;FromUserName&apos;] fromUser = itchat.search_friends(userName=fromUserName) nickName = fromUser[&apos;NickName&apos;] return nickName# 获取文字def getText(msg): if msg[&apos;Type&apos;] == &apos;Text&apos;: return msg[&apos;Text&apos;] else: return &quot;发送的其他类型回复&quot;# 向智能小冰提问def xbAnswer(msg): xb = itchat.search_mps(name=&apos;小冰&apos;)[0] quest = getText(msg) if msg[&apos;Type&apos;] == &apos;Picture&apos;: msg[&apos;Text&apos;](msg[&apos;FileName&apos;]) itchat.send_image(msg[&apos;FileName&apos;],xb[&apos;UserName&apos;]) else: itchat.send_msg(quest, xb[&apos;UserName&apos;])itchat.auto_login()itchat.run()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/python/"}]},{"title":"参加上海交大人工智能校友会有感","slug":"参加上海交大人工智能校友会有感","date":"2019-01-12T12:42:00.000Z","updated":"2019-01-12T14:15:32.532Z","comments":true,"path":"2019/01/12/参加上海交大人工智能校友会有感/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/01/12/参加上海交大人工智能校友会有感/","excerpt":"","text":"由于前一段时间报名参加了交大人工智能校友成立大会，于是今天吃过午饭就往交大闵行出发，实在是太远，两个小时左右才赶到交大，从剑川路地铁下来一路走到北一门，还是很熟悉的路。但是路边的建筑却有很大变化，曾经荒芜的剑川路北面现在却开发了，有一些公司以及有个小公园了。之后在交大校园里骑着哈罗单车简单逛了一下就赶往陈瑞球楼了。 大会也在两点半准时开始，出席会议的人中果然有一些大佬参加，来也、流利说、商汤科技、触宝等公司的创始人也都是交大校友，都是一些商业成功人士或者校领导。会议主要是一下在AI界创业以及在微软这样的大公司高层领导的校友发言，发表自己对于AI的理解以及目前发展状况分析。以及校友会成立的目标。 从该会议我也总结了一下大佬们对于目前AI发展的见解，以及对于未来的期望。 未来人工智能就是最热的发展方向，很多行业也随之发生颠覆性变革，一些行业可能对于优秀的人来说无法替代，但是由于教师，医生等，AI可以替代百分之80以上，至少AI的效果可以超越这些人。 人工智能对于医疗来说是个大风口，也是少数几个目前已经落地的项目和行业，中国医疗行业还有很大潜力。解和中国的人口，未来在这块很多人都想来分一口羹，今天有位船院的杰出校友，居然也是搞医疗+人工智能行业。所以我认为我自己未来或许可以考虑这个方向，先学好算法，深度学习，接触一些医疗影像行业。 对于AI的发展情况的理解，同时有几位大佬认为，目前的AI有点类似于上世纪90年代末的互联网，那个时候互联网发展也是起步阶段，进展缓慢，但是后来迅猛发展，大家也都知道了，所以现阶段需要给时间，保持耐心，相信AI全面发展的时代很快就会到来。 对于目前AI落地遇到的一些问题来说，目前来说瓶颈不在于技术，技术目前发展很快，关键在于落地，而落地就有和多问题，比如今天有位CEO讲到一个案例，他们的医疗产品在检测一位80多岁的高龄血栓患者的时候，这位患者凌晨5点不行去世，后来查看日志，发现产品确实检测到患者血栓严重问题，只是无法及时通知到值班医生，导致错过了救治的最佳时间，所以说如何实现落地可能就在与业务方面人员和实现。但是我认为至少目前AI不会受到太多伦理的考验，不像生物医药那样发展受限","categories":[],"tags":[]},{"title":"golang及web框架gin项目总结","slug":"golang及web框架gin项目总结","date":"2019-01-01T07:46:56.000Z","updated":"2019-02-11T08:38:58.939Z","comments":true,"path":"2019/01/01/golang及web框架gin项目总结/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/01/01/golang及web框架gin项目总结/","excerpt":"","text":"项目总结——后端项目总结（tea管理平台）近期接手了一个公司项目，使用golang语言作为后端语言，搭建一个文本管理平台，之前没有接触过golang，其实只会python，这正好给我学习一门和语言的机会，于是我从基础语法学起，慢慢算是开始熟悉了golang语言。由于golang和python很不一样，它是强类型的静态语言，对于数据类型和结构需要声明，使用也有一些不同，我也是遇到很多坑，所以今天来总结一下，也算是为以后面试或者重新使用这门语言能迅速想起来。 GOPATH设置 GOPATH是go语言必须设置的，这和其他语言可能不太一样，可以使用go env查看当前GOPATH，可以在终端命令行类似使用export GOPATH=/home/mas/go 设置， go切片 一开始我误以为golang中切片与python中的列表差不多，其实差的很多，虽然都是中括号中的数组，python中是 以英文逗号隔开的，go中是空格，go中的切片需要声明长度，并且需要一个一个往里面填值，而不能还第0个值没有的情况下，就直接给第2个值赋值，这样会报错，这就跟python很大不同。 go中各种类型转化 字符串，整型，浮点型转换，可以直接使用int(),float64()，但是转为字符串不能直接使用string()，特别是数字，转为字符串会得到ascii码，比如string(64)等到的可能就是ascii码中的大写字母C，那么怎么获得字符串”64呢？可以使用strconv包，strconv.Atoi字符串转int，strconv.Itoa 将整型转string。 struct，map，json字符串互相转换，这个是我做项目遇到最多的情况，很多时候声明数据结构需要使用struct，但是需要的结果又是其他类型，比如map类型或者字符串，就需要做转换，struct转map，可以使用json.Mashal先转为json格式字符串，再解析成map `type Person struct { Name string `json:&quot;-&quot;` Age int64 `json:&quot;-&quot;` Birth time.Time `json:&quot;-&quot;` Children []string `json:&quot;-&quot;` } jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes))` golang中interface{}和struct的使用 golang判断map的key存在 if _, ok := map[key]; ok { //存在 } Gin框架总结 安装 go get -u github.com/gin-gonic/gin API示例（括号里为路由和函数方法） router.GET(&quot;/someGet&quot;, getting) router.POST(&quot;/somePost&quot;, posting) path中参数解析 c.Param(“”)获取”/user/:name” 查询字符串参数 响应类似请求 /welcome?firstname=Jane&amp;lastname=Doe c.Query(“lastname”) POST请求 提交表单数据： router.POST(&quot;/form_post&quot;, func(c *gin.Context) { message := c.PostForm(&quot;message&quot;) nick := c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;) 提交字符串参数 id := c.Query(&quot;id&quot;) page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;) name := c.PostForm(&quot;name&quot;) message := c.PostForm(&quot;message&quot;) 上传文件： router.POST(&quot;/upload&quot;, func(c *gin.Context) { // 单文件 file, _ := c.FormFile(&quot;file&quot;) log.Println(file.Filename) router.POST(&quot;/upload&quot;, func(c *gin.Context) { // Multipart form 多文件 form, _ := c.MultipartForm() files := form.File[&quot;upload[]&quot;] 路由群组 // 简单组： v1 v1 := router.Group(&quot;/v1&quot;) { v1.POST(&quot;/login&quot;, loginEndpoint) v1.POST(&quot;/submit&quot;, submitEndpoint) v1.POST(&quot;/read&quot;, readEndpoint) } // 简单组： v2 v2 := router.Group(&quot;/v2&quot;) { v2.POST(&quot;/login&quot;, loginEndpoint) v2.POST(&quot;/submit&quot;, submitEndpoint) v2.POST(&quot;/read&quot;, readEndpoint) } gin.New()和gin.Default()区别 gin.New()默认的没有中间件的空白 Gin r := gin.Default()// Default 已经连接了 Logger 和 Recovery 中间件 HTML渲染 c.HTML(http.StatusOK, &quot;index.html&quot;, gin.H{ &quot;title&quot;: &quot;Main website&quot;, })","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/golang/"}]},{"title":"总结一下自己游泳的心得","slug":"总结一下自己游泳的心得","date":"2018-12-16T14:00:22.000Z","updated":"2019-01-01T03:18:21.332Z","comments":true,"path":"2018/12/16/总结一下自己游泳的心得/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/12/16/总结一下自己游泳的心得/","excerpt":"","text":"分享自己学习游泳的心得对于游泳的印象让我此时此刻回想起我对于游泳最初的影响，大概是这样一幅画画面：夕阳西下，几艘小船飘荡在江流的岸边，几只鹭鸶落在一根长杆上，眼睛东张西望。偶尔有装满沙子的轮船徐徐穿过江流，当然，还有一群小伙子在水中嬉闹。这就是我小时候游泳的地方啊，那时的水还非常清澈， 大概那时的我只有8、9岁，一到夏天最喜欢的事就是去江边游泳，那时刚刚开始学游泳，感谢我爸那时候教我游泳。 一开始学习游泳我也是很怕的，但是往往克服恐惧才是学习一项新技能的开始，对于游泳我觉得这是非常重要的一步，很多人往往害怕导致动作不对，拼命挣扎，反而使自己沉入水中越快。相反，你只要不害怕，记住动作，还没有沉下去的时候就不要害怕，反而不会沉下去。作为一名生物硕士，从基因上来说，人类最原始的基因中肯定还留着在水中获得的技能，比如每个人都是一开始生活在母亲的羊水中，人类最原始也是从海洋中进化来的，水对于人类来说不会陌生，昨天看了电影《海王》,那种在水中自由自在的感觉真美好，畅游在水中的感觉非常美妙。 闲扯了很多，下面就开始介绍关于游泳的技能吧 踩水 可以说我认为踩水应该是学会游泳的第一步，因为学会了这项技能你就可以在水中轻松自如，不用害怕沉下去，你就可以不会紧张地学其他的泳姿了，可以说是学会游泳的基础了。关于踩水还是以在水中实践为主，双手与双脚并用，当然等你很熟练之后，你只需要手会只动脚就够了，这个其实很重要，试想一下，你在深水区脚抽筋了怎么办，这时候你只要不停地用手上下划就够了，等待救援。踩水呢，其实就是对抗下沉，当你在沉下去的过程中，你只要用手往下一划，用脚往下踩，就可以轻松的升上去，就这样反复，放轻松，就不会沉下去。其实人的密度和水非常接近，你只要不动下沉也会非常慢，反而挣扎会让你沉得更快。这里教大家一个诀窍，人是通过胸腔的扩张来呼吸的，当你吸气，胸腔扩展的时候，人的体积增大，密度就相对来说减少，这时候人的密度通常低于水，也就是说这时候人在水中根本不会沉，但是人不可能一直处于吸气的状态，你可以吐气之后再次吸气，掌握这个节奏，即使手脚不动人也不会沉，怎么样？掌握这个时候还害怕沉入水中吗?水还有什么可怕的呢，你不会任何泳姿也没关系，你也可以轻松的在水中悠然自得。是不是很神奇，所以完全没必要害怕水。同时我认为学习游泳的第一步就是踩水和掌握呼吸让自己在水中沉浮，学会了这个，你之后的游泳技能将会非常容易。 第一个泳姿 掌握踩水和呼吸之后，那么你就开始学泳姿了，我比较熟练的是自由泳和蛙泳，我是先练习的自由泳，之后才学的蛙泳，不过我建议新人还是先学习蛙泳，因为蛙泳相对来说更容易一点，但是自由泳也是掌握之后游泳必学的。自由泳关键的在于腿，主要靠腿来使人前进，标准动作是这样的，先头部和上半身入水，手往后面和下面的45°方向用力划，一方面让人前进，一方面让人出水进行吸气，在水下的时候一定要记得吐气，吐得越多越好，这样才会刺激你出水后进行吸气，手刚化完之后立马脚跟上往两侧一等，往中间收，相信见过青蛙游泳的人会比较有体会，脚登完之后并拢加载一起飘一会，在开始下一个动作。首先需要你学会唤起，之后学会使用力气，把力气用在对抗水的阻力上，不去做无用阻力对抗。之后就需要你熟练动作，熟练换气的节奏，等你掌握这些之后你就可以游出较长的距离了。 自由泳 自由泳应该算是我最擅长的了，我参加过两次户外游泳的比赛，一次是金山铁人三项比赛，一次是滴水湖泳渡比赛，使用的都是自由泳，自由泳当然是最轻松最省力的方式。自由最关键的是靠手臂的力量，掌握划臂的技巧可以让你自由泳轻松不少；其次自由泳腰部力量也需要注意，保持住固定，防止摇动，所以游泳对于腰部也是有训练到的，大多数游泳爱好者很少有腰部赘肉，就像本人一样（-.-），最后是腿我认识到的游泳爱好者，不会使用腿，或者腿部姿势不正确，其实自由泳的时候很轻松，脚掌绷直，靠脚掌，滑动，像鸭子的脚掌一样，大腿和小腿只需要小幅度上下滑动，否则就会很费力，这样是最省力有高效的方法。 换气 我个人觉得换气是新手很难掌握的，对于游泳来说也是非常重要的，可能很多人以为换气重要的是吸气，但是我认为相反，吐气才更重要，很多人在水下不会吐气，而把呼吸都放在水上，这样肯定掌握不好呼吸的节奏，在水下的时候一定要吐气，而且要狠狠的吐，尽量吐完，这样你在水上的时候就会自然而然去吸气，所以换气的秘诀就在这里，很多人掌握不好呼吸的节奏，就是因为不懂得吐气。 前翻蹬壁 最后说的炫技的技巧，以前我不会前翻蹬壁的时候，看见别人做都很羡慕，感觉很专业，也觉得很难，但是当我学会的时候觉得很轻松，并没有多难。学会这个动作的关键就是去尝试，寻找感觉，前身一定要发力带动腰部，腿用力向后，就会自然而然翻过去，这个动作我也练习了很久，关键是要去练，当你学会的时候就可以在泳池轻松炫技了，别人看见你会这个一定会认为你是个高手的，哈哈。","categories":[],"tags":[{"name":"健身","slug":"健身","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/健身/"}]},{"title":"20181208上海大雪有感","slug":"20181208上海大雪有感","date":"2018-12-08T03:56:24.000Z","updated":"2018-12-08T04:48:04.208Z","comments":true,"path":"2018/12/08/20181208上海大雪有感/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/12/08/20181208上海大雪有感/","excerpt":"","text":"这算是我第二篇博客了，最近写代码很忙一直没时间写博客，今天上海突然下雪了，比以往来得更早一些（怎么不知不觉唱出来了0.0），这也是我第一次记一些感想吧，而不是积累技术。 时间真的过的很快，今天其实算是很充实的一年，3月份决定学编程，一路坚持下来，7月份成功入职现在的公司，做爬虫，做后端开发。不断的学习，也让我领悟到一个道理，明确自己的目标，坚持下去一定可以成功，这点我深信不疑。但是我还远谈不上成功，自己仍还有很长的路要走，自己还有太多太多的技能需要提高，但是昨晚发生的事，让我再一次意识到，语言表达，逻辑思维的重要性，而不是只会去学习编程，因为与人沟通，善于表达真的很重要很重要。 昨晚被同事叫去玩狼人杀，有一次暴露了自己逻辑混乱，语言组织能力极差的特点，让自己再一次极度自卑，于是整晚思考过后，我下定决心做出改变了。曾经对写代码一窍不通，于是我不断地practise,总算入门了，曾经我打字都手残，很慢，但是不断地practise，我也可以迅速地盲打，等等这些事也让自己清楚，不断地训练一定可以学会一件事，我相信等我也变得会表达之后，我的人生会上一个台阶。 我相信暴露缺点是好事，回想以前我是多么的傻，不知道去改变，没有语言天赋，去固步自封，不思进取，结果语言表达能力越来越差，这给我造成很大的困扰，也让我的人生失去很多机会，现在会想起以前前女友给我的训斥，我却不理会，是多么的傻，多么的可悲，大概这也让她对我失望了吧，或者说是肯定失望了吧，所以啊，江耀祖，你再不改变自己，将变得一事无成。 在痛定思痛之后，我一定要改变自己，故做出以下计划： 每天阅读书籍，朗读古诗半小时，睡前； 找一切机会让自己能说话，有机会的时候，就抓住，比如和陌生人说话，跟同事聊天，刻意去制造机会； 多看报，看新闻，这样也有说的话题； 有时间跟着主播，主持人朗读，学习怎么说话； 遇到好的句子一定要记录下来，可以记在手机便签里面。 有机会再补充吧，关键是一定要做到。总之，我真的再不改变就完了，不能再忍受这样的自己了，不能再让人笑话了，努力改变，以后就会让很久不见的朋友刮目相看了。另外，多写写东西，博客就是好的平台，无论是技术积累、日常感想，还是兴趣爱好，比如以后写一下自己的游泳和健身心得，分享出来。 今天下雪了，这种天气让人更加多愁善感，天气很寒冷，心情有点低落，但是不能自暴自弃，期待一个变得更优秀的自己。2018年12月8号，中午12点31分。","categories":[{"name":"cate","slug":"cate","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/cate/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/随笔/"}]},{"title":"go语言中减少类型层次使用","slug":"go语言中减少类型层次使用","date":"2018-11-13T13:48:24.000Z","updated":"2018-12-08T04:51:51.711Z","comments":true,"path":"2018/11/13/go语言中减少类型层次使用/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/11/13/go语言中减少类型层次使用/","excerpt":"","text":"减少类型层次介绍我发现许多面向对象的编程语言（如 C＃和 Java）的开发人员转向 Go语言。 由于这些开发人员已接受过使用类型层次结构的培训，因此他们在 Go中使用相同的模式是有道理的。 但是 Go语言的某些方面，不允许类型层次结构提供与其他面向对象编程语言相同的功能级别。 具体来说，Go中不存在基类和子类的概念，因此类重用需要不同的思维方式。 在这篇文章中，我将展示为什么类型层次结构在Go语言中使用，并不总是最佳模式。 我将解释为什么将具体类型组合在一起最好的办法，是通过共同的行为，而不是通过共同的状态。 我将展示如何利用接口来分组和解耦具体类型，最后，我将提供一些关于声明类型的指南。 第一部分让我们从一个程序开始，正如我经常看到那些试图学习 Go的人也是这样。 该程序使用传统的类型层次结构模式，这种模式在面向对象的程序中很常见。 https://play.golang.org/p/ZNWmyoj55W 表 1:123456789101112131415161701 package main0203 import &quot;fmt&quot;0405 //Animal 包含动物的所有基本领域。06 type Animal struct &#123;07 Name string08 IsMammal bool09 &#125;1011 // Speak 为所有动物提供通用行为以及它们如何说话。13 func (a Animal) Speak() &#123;14 fmt.Println(&quot;UGH!&quot;,15 &quot;My name is&quot;, a.Name,16 &quot;, it is&quot;, a.IsMammal,17 &quot;I am a mammal&quot;)18 &#125; 在表1中，我们看到了传统面向对象程序的开始。 在第06行，我们有具体类型Animal的声明，它有两个字段，Name 和 IsMammal。 然后在第13行，我们有一个名为 Speak的方法，允许动物说话。 由于 Animal是所有动物的基础类型，因此 Speak方法的实现是通用的，任何超出此基础状态的指定动物就不好使用了。 表 2:1234567891011121320 // Dog 包含 Animal 的所有，但只包含 Dog 的特定属性。22 type Dog struct &#123;23 Animal24 PackFactor int25 &#125;2627 // Speak 知道如何像狗一样叫28 func (d Dog) Speak() &#123;29 fmt.Println(&quot;Woof!&quot;,30 &quot;My name is&quot;, d.Name,31 &quot;, it is&quot;, d.IsMammal,32 &quot;I am a mammal with a pack factor of&quot;, d.PackFactor)33 &#125; 表2声明了一个名为 Dog的新具体类型，它嵌入了一个类型为 Animal 的值，并且具有一个名为 PackFactor 的唯一字段。 我们看到使用组合来重用Animal类型的字段和方法。 在这种情况下，组合在类型重用方面提供了一些与继承相同的好处。 Dog 类型还实现了自己的 Speak方法版本，允许 Dog 像狗一样吠叫。 此方法重写了实现Animal类型的 Speak方法。 表 3：12345678910111235 // Cat 有 Animal 的所有方法，但特殊的方法只有Cat有37 type Cat struct &#123;38 Animal39 ClimbFactor int40 &#125;4142 // Speak 知道如何像猫一样叫43 func (c Cat) Speak() &#123;44 fmt.Println(&quot;Meow!&quot;,45 &quot;My name is&quot;, c.Name,46 &quot;, it is&quot;, c.IsMammal,47 &quot;I am a mammal with a climb factor of&quot;, c.ClimbFactor) 接下来，我们在表3中有第三个具体类型，叫做Cat。它还嵌入了一个类型为Animal的值，并且有一个名为 ClimbFactor 的字段。 出于同样的原因，我们再次看到组合物的使用，并且 Cat 有一种名为 Speak 的方法，允许 Cat 像猫一样喵喵叫。 同样，此方法重写了实现 Animal 类型的 Speak 方法。 表 4：12345678910111213141516171819202122232450 func main() &#123;5152 // 通过初始化 Animal 的部分,然后初始化其特定 Dog 属性来创建 Dog54 d := Dog&#123;55 Animal: Animal&#123;56 Name: &quot;Fido&quot;,57 IsMammal: true,58 &#125;,59 PackFactor: 5,60 &#125;6162 // 通过初始化 Animal 的部分,然后初始化其特定Cat属性来创建 Cat64 c := Cat&#123;65 Animal: Animal&#123;66 Name: &quot;Milo&quot;,67 IsMammal: true,68 &#125;,69 ClimbFactor: 4,70 &#125;7172 // Have the Dog and Cat speak.73 d.Speak()74 c.Speak()75 &#125; 在表4中，我们将主要功能放在一起。 在第54行，我们使用字面结构体，创建 Dog 类型的值，并初始化嵌入的 Animal 值和 PackFactor 字段。 在第64行，我们使用字面结构体创建 Cat 类型的值，并初始化嵌入的 Animal 值和 ClimbFactor 字段。 然后，最后，我们在第73行和第74行给 Dog 和 Cat 值调用 Speak 方法。 这适用于 Go 语言，您可以看到嵌入类型的使用如何提供熟悉的类型层次结构功能。 然而，在 Go 语言中执行此操作存在一些缺陷，原因之一是 Go 不支持子类型的概念。 这意味着您不能像在其他面向对象的语言中那样使用 Animal 类型作为基类型。 重要的是要理解，在 Go 语言中，Dog 和 Cat 类型不能用作 Animal 类型的值。 我们所拥有的是为Dog和Cat类型嵌入了Animal 类型的值。 您不能将 Dog 或 Cat 传递给任何接受 Animal 类型值的函数。 这也意味着无法通过Animal类型在同一列表中将一组 Cat 和 Dog 值组合在一起。 表 5：12345678910// 尝试使用 Animal 作为基类animals := []Animal&#123; Dog&#123;&#125; Cat&#123;&#125;,&#125;: cannot use Dog literal (type Dog) as type Animal in array or slice literal：在数组或列表中不能使用 Dog 类作为 Animal 类: cannot use Cat literal (type Cat) as type Animal in array or slice literal：在数组或列表中不能使用 Cat 类作为 Animal 类 表5显示了当您尝试将 Animal 类型用作传统面向对象方式的基类时，Go 语言中发生的情况。 编译器非常清楚 Dog 和 Cat 类不能用作Animal类。 在这种情况下，Animal 类型和类型层次结构的使用并没有为我们提供任何实际价值。 我认为它正在引领我们走上一条不可读，不简单，适应性不强的代码之路。 第二部分在 Go 语言中编码时，尽量避免使用这些类型层次结构来促进共同状态的思想，并考虑共同行为。 如果我们考虑他们展示的共同行为，我们可以将一组狗和猫的值分组。 在这种情况下，Speak 有一个共同的行为。 让我们看看这段代码的另一个实现，它关注行为。 https://play.golang.org/p/6aLyTOTIj_ 表 6：1234567891001 package main0203 import &quot;fmt&quot;0405 // 如果他们想成为这个群体的一部分，06 // 扬声器为所有具体类型提供了一个共同的行为，07 // 这是这些具体类型的约定。08 type Speaker interface &#123;09 Speak()10 &#125; 新程序从表6开始，我们在第08行添加了一个名为 Speaker 的新类型。这不是我们之前声明的结构体类型的具体类型。 这是一种接口类型，它声明了一个行为约定，它允许我们对一组实现 Speak 方法的不同具体类型进行分组和处理。 表 7：12345678910111213141516171819202122232425262728293031323312 // Dog 结构体包含 Dog 需要的一切13 type Dog struct &#123;14 Name string15 IsMammal bool16 PackFactor int17 &#125;1819 // Speak 知道如何像狗一样叫20 // 这使得 Dog 现在成为了解如何说话的一组具体类型的一部分。2122 func (d Dog) Speak() &#123;23 fmt.Println(&quot;Woof!&quot;,24 &quot;My name is&quot;, d.Name,25 &quot;, it is&quot;, d.IsMammal,26 &quot;I am a mammal with a pack factor of&quot;, d.PackFactor)27 &#125;2829 // Cat 结构体包含 Cat 需要的一切30 type Cat struct &#123;31 Name string32 IsMammal bool33 ClimbFactor int34 &#125;3536 // Speak 知道怎样像猫一样叫37 // 这使得 Cat 现在成为了解如何说话的一组具体类型的一部分。3839 func (c Cat) Speak() &#123;40 fmt.Println(&quot;Meow!&quot;,41 &quot;My name is&quot;, c.Name,42 &quot;, it is&quot;, c.IsMammal,43 &quot;I am a mammal with a climb factor of&quot;, c.ClimbFactor)44 &#125; 在表7中，我们再次声明了具体类型的狗和猫。 此代码删除Animal类型并将这些公共字段直接复制到 Dog 和 Cat 中。 我们为什么那么做？ Animal 类型提供了可重用状态的抽象层。 该程序从不需要创建或仅使用 Animal 类型的值。 Animal 类型的 Speak 方法的实现是一种概括。 以下是有关声明类型的一些指导原则 声明类型表示新的或独特的事物。 验证是否自己创建或使用任何类型的值。 嵌入类型以重用您需要满足的现有行为。 作为现有类型的别名或抽象的问题类型。 其唯一目的是分享共同状态的问题类型。 让我们现在来看一下主函数 main 表 8：12345678910111213141516171819202122232425262746 func main() &#123;4748 // 创建一个知道如何说话的动物列表49 speakers := []Speaker&#123;5051 // 通过初始化其 Animal 部分，然后初始化其特定的 Dog 属性来创建一个52 // Dog。53 Dog&#123;54 Name: &quot;Fido&quot;,55 IsMammal: true,56 PackFactor: 5,57 &#125;,5859 // 通过初始化其 Animal 部分，然后初始化其特定的 Dog 属性来创建60 // 一个Cat61 Cat&#123;62 Name: &quot;Milo&quot;,63 IsMammal: true,64 ClimbFactor: 4,65 &#125;,66 &#125;6768 // 让Animal叫69 for _, spkr := range speakers &#123;70 spkr.Speak()71 &#125;72 &#125; 在表8的第49行，我们创建了一个 Speaker 接口值列表，以便在其常见行为下将 Dog 和 Cat 值组合在一起。 我们在第53行创建了 Dog 类型的值，在第61行创建了 Cat 类型的值。最后在第69-71行，我们迭代了 Speaker 接口值的列表并让 Dog 和 Cat 说话。 关于我们所做的改变的一些最终想法： 我们不需要基类或类型层次结构来将具体类型值组合在一起。 接口允许我们创建一个不同具体类型值的切片，并通过它们的共同行为来处理这些值。 我们通过不声明一个从未被程序单独使用过的类型，来消除类型污染。 总结Go 语言中的组合还有很多，但这是对使用类型层次结构的问题的初步理解。 每条规则总是有例外情况，但请务必遵循这些指导原则，直到您足够了解做出异常的权衡。 要了解有关此文章所涉及的构图和其他主题的更多信息，请查看以下其他博文： Exported/Unexported Identifiers In Go Methods Interfaces And Embedded Types Object Oriented Mechanics In Go Composition With Go 鸣谢以下是社区的一些朋友，我想感谢他们花时间审阅帖子并提供反馈。 Daniel Vaughan, Ted Young, Antonio Troina, Adam Straughan, Kaveh Shahbazian, Daniel Whitenack, Todd Rafferty via: https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html 作者：William Kennedy 译者：Jasonjiang27 校对：校对者ID 本文由 GCTT 原创编译，Go 中文网 荣誉推出","categories":[{"name":"cate","slug":"cate","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/cate/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/golang/"}]},{"title":"My New Post","slug":"My-New-Post","date":"2018-11-12T15:53:23.000Z","updated":"2018-11-13T13:55:57.039Z","comments":true,"path":"2018/11/12/My-New-Post/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/11/12/My-New-Post/","excerpt":"","text":"很高兴学会了自己搭建博客，以后学会积累，学会分享，路漫漫其修远兮，吾将上下而求索~ 相信自己一定可以成功！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-12T14:52:20.970Z","updated":"2018-11-12T14:52:20.970Z","comments":true,"path":"2018/11/12/hello-world/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/11/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}