{"meta":{"title":"江耀祖的blog","subtitle":"努力提高自己才是生活的意义","description":"python golang 互联网 随笔 健身 生活","author":"Jasonjiang","url":"https://Jasonjiang27.github.io/Jasonjiang27.github.io"},"pages":[{"title":"关于","date":"2018-11-13T14:04:49.000Z","updated":"2018-11-13T14:05:40.932Z","comments":true,"path":"about/index.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/about/index.html","excerpt":"","text":"这是关于页。。。"},{"title":"分类","date":"2018-11-13T14:07:06.000Z","updated":"2018-12-08T04:48:26.212Z","comments":false,"path":"categories/index.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-13T14:05:57.000Z","updated":"2018-11-13T14:06:41.336Z","comments":true,"path":"tags/index.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-08T04:41:01.000Z","updated":"2018-12-08T04:41:01.573Z","comments":true,"path":"tags/index-1.html","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"参加上海交大人工智能校友会有感","slug":"参加上海交大人工智能校友会有感","date":"2019-01-12T12:42:00.000Z","updated":"2019-01-12T14:15:32.532Z","comments":true,"path":"2019/01/12/参加上海交大人工智能校友会有感/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/01/12/参加上海交大人工智能校友会有感/","excerpt":"","text":"由于前一段时间报名参加了交大人工智能校友成立大会，于是今天吃过午饭就往交大闵行出发，实在是太远，两个小时左右才赶到交大，从剑川路地铁下来一路走到北一门，还是很熟悉的路。但是路边的建筑却有很大变化，曾经荒芜的剑川路北面现在却开发了，有一些公司以及有个小公园了。之后在交大校园里骑着哈罗单车简单逛了一下就赶往陈瑞球楼了。 大会也在两点半准时开始，出席会议的人中果然有一些大佬参加，来也、流利说、商汤科技、触宝等公司的创始人也都是交大校友，都是一些商业成功人士或者校领导。会议主要是一下在AI界创业以及在微软这样的大公司高层领导的校友发言，发表自己对于AI的理解以及目前发展状况分析。以及校友会成立的目标。 从该会议我也总结了一下大佬们对于目前AI发展的见解，以及对于未来的期望。 未来人工智能就是最热的发展方向，很多行业也随之发生颠覆性变革，一些行业可能对于优秀的人来说无法替代，但是由于教师，医生等，AI可以替代百分之80以上，至少AI的效果可以超越这些人。 人工智能对于医疗来说是个大风口，也是少数几个目前已经落地的项目和行业，中国医疗行业还有很大潜力。解和中国的人口，未来在这块很多人都想来分一口羹，今天有位船院的杰出校友，居然也是搞医疗+人工智能行业。所以我认为我自己未来或许可以考虑这个方向，先学好算法，深度学习，接触一些医疗影像行业。 对于AI的发展情况的理解，同时有几位大佬认为，目前的AI有点类似于上世纪90年代末的互联网，那个时候互联网发展也是起步阶段，进展缓慢，但是后来迅猛发展，大家也都知道了，所以现阶段需要给时间，保持耐心，相信AI全面发展的时代很快就会到来。 对于目前AI落地遇到的一些问题来说，目前来说瓶颈不在于技术，技术目前发展很快，关键在于落地，而落地就有和多问题，比如今天有位CEO讲到一个案例，他们的医疗产品在检测一位80多岁的高龄血栓患者的时候，这位患者凌晨5点不行去世，后来查看日志，发现产品确实检测到患者血栓严重问题，只是无法及时通知到值班医生，导致错过了救治的最佳时间，所以说如何实现落地可能就在与业务方面人员和实现。但是我认为至少目前AI不会受到太多伦理的考验，不像生物医药那样发展受限","categories":[],"tags":[]},{"title":"golang及web框架gin项目总结","slug":"golang及web框架gin项目总结","date":"2019-01-01T07:46:56.000Z","updated":"2019-01-06T09:48:12.481Z","comments":true,"path":"2019/01/01/golang及web框架gin项目总结/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2019/01/01/golang及web框架gin项目总结/","excerpt":"","text":"项目总结——后端项目总结（tea管理平台）近期接手了一个公司项目，使用golang语言作为后端语言，搭建一个文本管理平台，之前没有接触过golang，其实只会python，这正好给我学习一门和语言的机会，于是我从基础语法学起，慢慢算是开始熟悉了golang语言。由于golang和python很不一样，它是强类型的静态语言，对于数据类型和结构需要声明，使用也有一些不同，我也是遇到很多坑，所以今天来总结一下，也算是为以后面试或者重新使用这门语言能迅速想起来。 GOPATH设置 GOPATH是go语言必须设置的，这和其他语言可能不太一样，可以使用go env查看当前GOPATH，可以在终端命令行类似使用export GOPATH=/home/mas/go 设置， go切片 一开始我误以为golang中切片与python中的列表差不多，其实差的很多，虽然都是中括号中的数组，python中是 以英文逗号隔开的，go中是空格，go中的切片需要声明长度，并且需要一个一个往里面填值，而不能还第0个值没有的情况下，就直接给第2个值赋值，这样会报错，这就跟python很大不同。 go中各种类型转化 字符串，整型，浮点型转换，可以直接使用int(),float64()，但是转为字符串不能直接使用string()，特别是数字，转为字符串会得到ascii码，比如string(64)等到的可能就是ascii码中的大写字母C，那么怎么获得字符串”64呢？可以使用strconv包，strconv.Atoi字符串转int，strconv.Itoa 将整型转string。 struct，map，json字符串互相转换，这个是我做项目遇到最多的情况，很多时候声明数据结构需要使用struct，但是需要的结果又是其他类型，比如map类型或者字符串，就需要做转换，struct转map，可以使用json.Mashal先转为json格式字符串，再解析成map `type Person struct { Name string `json:&quot;-&quot;` Age int64 `json:&quot;-&quot;` Birth time.Time `json:&quot;-&quot;` Children []string `json:&quot;-&quot;` } jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes))` golang中interface{}和struct的使用 golang判断map的key存在 if _, ok := map[key]; ok { //存在 } Gin框架总结 安装 go get -u github.com/gin-gonic/gin API示例（括号里为路由和函数方法） router.GET(&quot;/someGet&quot;, getting) router.POST(&quot;/somePost&quot;, posting) path中参数解析 c.Param(“”)获取”/user/:name” 查询字符串参数 响应类似请求 /welcome?firstname=Jane&amp;lastname=Doe c.Query(“lastname”) POST请求 提交表单数据： router.POST(&quot;/form_post&quot;, func(c *gin.Context) { message := c.PostForm(&quot;message&quot;) nick := c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;) 提交字符串参数 id := c.Query(&quot;id&quot;) page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;) name := c.PostForm(&quot;name&quot;) message := c.PostForm(&quot;message&quot;) 上传文件： router.POST(&quot;/upload&quot;, func(c *gin.Context) { // 单文件 file, _ := c.FormFile(&quot;file&quot;) log.Println(file.Filename) router.POST(&quot;/upload&quot;, func(c *gin.Context) { // Multipart form 多文件 form, _ := c.MultipartForm() files := form.File[&quot;upload[]&quot;] 路由群组 // 简单组： v1 v1 := router.Group(&quot;/v1&quot;) { v1.POST(&quot;/login&quot;, loginEndpoint) v1.POST(&quot;/submit&quot;, submitEndpoint) v1.POST(&quot;/read&quot;, readEndpoint) } // 简单组： v2 v2 := router.Group(&quot;/v2&quot;) { v2.POST(&quot;/login&quot;, loginEndpoint) v2.POST(&quot;/submit&quot;, submitEndpoint) v2.POST(&quot;/read&quot;, readEndpoint) } gin.New()和gin.Default()区别 gin.New()默认的没有中间件的空白 Gin r := gin.Default()// Default 已经连接了 Logger 和 Recovery 中间件 HTML渲染 c.HTML(http.StatusOK, &quot;index.html&quot;, gin.H{ &quot;title&quot;: &quot;Main website&quot;, })","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/golang/"}]},{"title":"总结一下自己游泳的心得","slug":"总结一下自己游泳的心得","date":"2018-12-16T14:00:22.000Z","updated":"2019-01-01T03:18:21.332Z","comments":true,"path":"2018/12/16/总结一下自己游泳的心得/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/12/16/总结一下自己游泳的心得/","excerpt":"","text":"分享自己学习游泳的心得对于游泳的印象让我此时此刻回想起我对于游泳最初的影响，大概是这样一幅画画面：夕阳西下，几艘小船飘荡在江流的岸边，几只鹭鸶落在一根长杆上，眼睛东张西望。偶尔有装满沙子的轮船徐徐穿过江流，当然，还有一群小伙子在水中嬉闹。这就是我小时候游泳的地方啊，那时的水还非常清澈， 大概那时的我只有8、9岁，一到夏天最喜欢的事就是去江边游泳，那时刚刚开始学游泳，感谢我爸那时候教我游泳。 一开始学习游泳我也是很怕的，但是往往克服恐惧才是学习一项新技能的开始，对于游泳我觉得这是非常重要的一步，很多人往往害怕导致动作不对，拼命挣扎，反而使自己沉入水中越快。相反，你只要不害怕，记住动作，还没有沉下去的时候就不要害怕，反而不会沉下去。作为一名生物硕士，从基因上来说，人类最原始的基因中肯定还留着在水中获得的技能，比如每个人都是一开始生活在母亲的羊水中，人类最原始也是从海洋中进化来的，水对于人类来说不会陌生，昨天看了电影《海王》,那种在水中自由自在的感觉真美好，畅游在水中的感觉非常美妙。 闲扯了很多，下面就开始介绍关于游泳的技能吧 踩水 可以说我认为踩水应该是学会游泳的第一步，因为学会了这项技能你就可以在水中轻松自如，不用害怕沉下去，你就可以不会紧张地学其他的泳姿了，可以说是学会游泳的基础了。关于踩水还是以在水中实践为主，双手与双脚并用，当然等你很熟练之后，你只需要手会只动脚就够了，这个其实很重要，试想一下，你在深水区脚抽筋了怎么办，这时候你只要不停地用手上下划就够了，等待救援。踩水呢，其实就是对抗下沉，当你在沉下去的过程中，你只要用手往下一划，用脚往下踩，就可以轻松的升上去，就这样反复，放轻松，就不会沉下去。其实人的密度和水非常接近，你只要不动下沉也会非常慢，反而挣扎会让你沉得更快。这里教大家一个诀窍，人是通过胸腔的扩张来呼吸的，当你吸气，胸腔扩展的时候，人的体积增大，密度就相对来说减少，这时候人的密度通常低于水，也就是说这时候人在水中根本不会沉，但是人不可能一直处于吸气的状态，你可以吐气之后再次吸气，掌握这个节奏，即使手脚不动人也不会沉，怎么样？掌握这个时候还害怕沉入水中吗?水还有什么可怕的呢，你不会任何泳姿也没关系，你也可以轻松的在水中悠然自得。是不是很神奇，所以完全没必要害怕水。同时我认为学习游泳的第一步就是踩水和掌握呼吸让自己在水中沉浮，学会了这个，你之后的游泳技能将会非常容易。 第一个泳姿 掌握踩水和呼吸之后，那么你就开始学泳姿了，我比较熟练的是自由泳和蛙泳，我是先练习的自由泳，之后才学的蛙泳，不过我建议新人还是先学习蛙泳，因为蛙泳相对来说更容易一点，但是自由泳也是掌握之后游泳必学的。自由泳关键的在于腿，主要靠腿来使人前进，标准动作是这样的，先头部和上半身入水，手往后面和下面的45°方向用力划，一方面让人前进，一方面让人出水进行吸气，在水下的时候一定要记得吐气，吐得越多越好，这样才会刺激你出水后进行吸气，手刚化完之后立马脚跟上往两侧一等，往中间收，相信见过青蛙游泳的人会比较有体会，脚登完之后并拢加载一起飘一会，在开始下一个动作。首先需要你学会唤起，之后学会使用力气，把力气用在对抗水的阻力上，不去做无用阻力对抗。之后就需要你熟练动作，熟练换气的节奏，等你掌握这些之后你就可以游出较长的距离了。 自由泳 自由泳应该算是我最擅长的了，我参加过两次户外游泳的比赛，一次是金山铁人三项比赛，一次是滴水湖泳渡比赛，使用的都是自由泳，自由泳当然是最轻松最省力的方式。自由最关键的是靠手臂的力量，掌握划臂的技巧可以让你自由泳轻松不少；其次自由泳腰部力量也需要注意，保持住固定，防止摇动，所以游泳对于腰部也是有训练到的，大多数游泳爱好者很少有腰部赘肉，就像本人一样（-.-），最后是腿我认识到的游泳爱好者，不会使用腿，或者腿部姿势不正确，其实自由泳的时候很轻松，脚掌绷直，靠脚掌，滑动，像鸭子的脚掌一样，大腿和小腿只需要小幅度上下滑动，否则就会很费力，这样是最省力有高效的方法。 换气 我个人觉得换气是新手很难掌握的，对于游泳来说也是非常重要的，可能很多人以为换气重要的是吸气，但是我认为相反，吐气才更重要，很多人在水下不会吐气，而把呼吸都放在水上，这样肯定掌握不好呼吸的节奏，在水下的时候一定要吐气，而且要狠狠的吐，尽量吐完，这样你在水上的时候就会自然而然去吸气，所以换气的秘诀就在这里，很多人掌握不好呼吸的节奏，就是因为不懂得吐气。 前翻蹬壁 最后说的炫技的技巧，以前我不会前翻蹬壁的时候，看见别人做都很羡慕，感觉很专业，也觉得很难，但是当我学会的时候觉得很轻松，并没有多难。学会这个动作的关键就是去尝试，寻找感觉，前身一定要发力带动腰部，腿用力向后，就会自然而然翻过去，这个动作我也练习了很久，关键是要去练，当你学会的时候就可以在泳池轻松炫技了，别人看见你会这个一定会认为你是个高手的，哈哈。","categories":[],"tags":[{"name":"健身","slug":"健身","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/健身/"}]},{"title":"20181208上海大雪有感","slug":"20181208上海大雪有感","date":"2018-12-08T03:56:24.000Z","updated":"2018-12-08T04:48:04.208Z","comments":true,"path":"2018/12/08/20181208上海大雪有感/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/12/08/20181208上海大雪有感/","excerpt":"","text":"这算是我第二篇博客了，最近写代码很忙一直没时间写博客，今天上海突然下雪了，比以往来得更早一些（怎么不知不觉唱出来了0.0），这也是我第一次记一些感想吧，而不是积累技术。 时间真的过的很快，今天其实算是很充实的一年，3月份决定学编程，一路坚持下来，7月份成功入职现在的公司，做爬虫，做后端开发。不断的学习，也让我领悟到一个道理，明确自己的目标，坚持下去一定可以成功，这点我深信不疑。但是我还远谈不上成功，自己仍还有很长的路要走，自己还有太多太多的技能需要提高，但是昨晚发生的事，让我再一次意识到，语言表达，逻辑思维的重要性，而不是只会去学习编程，因为与人沟通，善于表达真的很重要很重要。 昨晚被同事叫去玩狼人杀，有一次暴露了自己逻辑混乱，语言组织能力极差的特点，让自己再一次极度自卑，于是整晚思考过后，我下定决心做出改变了。曾经对写代码一窍不通，于是我不断地practise,总算入门了，曾经我打字都手残，很慢，但是不断地practise，我也可以迅速地盲打，等等这些事也让自己清楚，不断地训练一定可以学会一件事，我相信等我也变得会表达之后，我的人生会上一个台阶。 我相信暴露缺点是好事，回想以前我是多么的傻，不知道去改变，没有语言天赋，去固步自封，不思进取，结果语言表达能力越来越差，这给我造成很大的困扰，也让我的人生失去很多机会，现在会想起以前前女友给我的训斥，我却不理会，是多么的傻，多么的可悲，大概这也让她对我失望了吧，或者说是肯定失望了吧，所以啊，江耀祖，你再不改变自己，将变得一事无成。 在痛定思痛之后，我一定要改变自己，故做出以下计划： 每天阅读书籍，朗读古诗半小时，睡前； 找一切机会让自己能说话，有机会的时候，就抓住，比如和陌生人说话，跟同事聊天，刻意去制造机会； 多看报，看新闻，这样也有说的话题； 有时间跟着主播，主持人朗读，学习怎么说话； 遇到好的句子一定要记录下来，可以记在手机便签里面。 有机会再补充吧，关键是一定要做到。总之，我真的再不改变就完了，不能再忍受这样的自己了，不能再让人笑话了，努力改变，以后就会让很久不见的朋友刮目相看了。另外，多写写东西，博客就是好的平台，无论是技术积累、日常感想，还是兴趣爱好，比如以后写一下自己的游泳和健身心得，分享出来。 今天下雪了，这种天气让人更加多愁善感，天气很寒冷，心情有点低落，但是不能自暴自弃，期待一个变得更优秀的自己。2018年12月8号，中午12点31分。","categories":[{"name":"cate","slug":"cate","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/cate/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/随笔/"}]},{"title":"go语言中减少类型层次使用","slug":"go语言中减少类型层次使用","date":"2018-11-13T13:48:24.000Z","updated":"2018-12-08T04:51:51.711Z","comments":true,"path":"2018/11/13/go语言中减少类型层次使用/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/11/13/go语言中减少类型层次使用/","excerpt":"","text":"减少类型层次介绍我发现许多面向对象的编程语言（如 C＃和 Java）的开发人员转向 Go语言。 由于这些开发人员已接受过使用类型层次结构的培训，因此他们在 Go中使用相同的模式是有道理的。 但是 Go语言的某些方面，不允许类型层次结构提供与其他面向对象编程语言相同的功能级别。 具体来说，Go中不存在基类和子类的概念，因此类重用需要不同的思维方式。 在这篇文章中，我将展示为什么类型层次结构在Go语言中使用，并不总是最佳模式。 我将解释为什么将具体类型组合在一起最好的办法，是通过共同的行为，而不是通过共同的状态。 我将展示如何利用接口来分组和解耦具体类型，最后，我将提供一些关于声明类型的指南。 第一部分让我们从一个程序开始，正如我经常看到那些试图学习 Go的人也是这样。 该程序使用传统的类型层次结构模式，这种模式在面向对象的程序中很常见。 https://play.golang.org/p/ZNWmyoj55W 表 1:123456789101112131415161701 package main0203 import &quot;fmt&quot;0405 //Animal 包含动物的所有基本领域。06 type Animal struct &#123;07 Name string08 IsMammal bool09 &#125;1011 // Speak 为所有动物提供通用行为以及它们如何说话。13 func (a Animal) Speak() &#123;14 fmt.Println(&quot;UGH!&quot;,15 &quot;My name is&quot;, a.Name,16 &quot;, it is&quot;, a.IsMammal,17 &quot;I am a mammal&quot;)18 &#125; 在表1中，我们看到了传统面向对象程序的开始。 在第06行，我们有具体类型Animal的声明，它有两个字段，Name 和 IsMammal。 然后在第13行，我们有一个名为 Speak的方法，允许动物说话。 由于 Animal是所有动物的基础类型，因此 Speak方法的实现是通用的，任何超出此基础状态的指定动物就不好使用了。 表 2:1234567891011121320 // Dog 包含 Animal 的所有，但只包含 Dog 的特定属性。22 type Dog struct &#123;23 Animal24 PackFactor int25 &#125;2627 // Speak 知道如何像狗一样叫28 func (d Dog) Speak() &#123;29 fmt.Println(&quot;Woof!&quot;,30 &quot;My name is&quot;, d.Name,31 &quot;, it is&quot;, d.IsMammal,32 &quot;I am a mammal with a pack factor of&quot;, d.PackFactor)33 &#125; 表2声明了一个名为 Dog的新具体类型，它嵌入了一个类型为 Animal 的值，并且具有一个名为 PackFactor 的唯一字段。 我们看到使用组合来重用Animal类型的字段和方法。 在这种情况下，组合在类型重用方面提供了一些与继承相同的好处。 Dog 类型还实现了自己的 Speak方法版本，允许 Dog 像狗一样吠叫。 此方法重写了实现Animal类型的 Speak方法。 表 3：12345678910111235 // Cat 有 Animal 的所有方法，但特殊的方法只有Cat有37 type Cat struct &#123;38 Animal39 ClimbFactor int40 &#125;4142 // Speak 知道如何像猫一样叫43 func (c Cat) Speak() &#123;44 fmt.Println(&quot;Meow!&quot;,45 &quot;My name is&quot;, c.Name,46 &quot;, it is&quot;, c.IsMammal,47 &quot;I am a mammal with a climb factor of&quot;, c.ClimbFactor) 接下来，我们在表3中有第三个具体类型，叫做Cat。它还嵌入了一个类型为Animal的值，并且有一个名为 ClimbFactor 的字段。 出于同样的原因，我们再次看到组合物的使用，并且 Cat 有一种名为 Speak 的方法，允许 Cat 像猫一样喵喵叫。 同样，此方法重写了实现 Animal 类型的 Speak 方法。 表 4：12345678910111213141516171819202122232450 func main() &#123;5152 // 通过初始化 Animal 的部分,然后初始化其特定 Dog 属性来创建 Dog54 d := Dog&#123;55 Animal: Animal&#123;56 Name: &quot;Fido&quot;,57 IsMammal: true,58 &#125;,59 PackFactor: 5,60 &#125;6162 // 通过初始化 Animal 的部分,然后初始化其特定Cat属性来创建 Cat64 c := Cat&#123;65 Animal: Animal&#123;66 Name: &quot;Milo&quot;,67 IsMammal: true,68 &#125;,69 ClimbFactor: 4,70 &#125;7172 // Have the Dog and Cat speak.73 d.Speak()74 c.Speak()75 &#125; 在表4中，我们将主要功能放在一起。 在第54行，我们使用字面结构体，创建 Dog 类型的值，并初始化嵌入的 Animal 值和 PackFactor 字段。 在第64行，我们使用字面结构体创建 Cat 类型的值，并初始化嵌入的 Animal 值和 ClimbFactor 字段。 然后，最后，我们在第73行和第74行给 Dog 和 Cat 值调用 Speak 方法。 这适用于 Go 语言，您可以看到嵌入类型的使用如何提供熟悉的类型层次结构功能。 然而，在 Go 语言中执行此操作存在一些缺陷，原因之一是 Go 不支持子类型的概念。 这意味着您不能像在其他面向对象的语言中那样使用 Animal 类型作为基类型。 重要的是要理解，在 Go 语言中，Dog 和 Cat 类型不能用作 Animal 类型的值。 我们所拥有的是为Dog和Cat类型嵌入了Animal 类型的值。 您不能将 Dog 或 Cat 传递给任何接受 Animal 类型值的函数。 这也意味着无法通过Animal类型在同一列表中将一组 Cat 和 Dog 值组合在一起。 表 5：12345678910// 尝试使用 Animal 作为基类animals := []Animal&#123; Dog&#123;&#125; Cat&#123;&#125;,&#125;: cannot use Dog literal (type Dog) as type Animal in array or slice literal：在数组或列表中不能使用 Dog 类作为 Animal 类: cannot use Cat literal (type Cat) as type Animal in array or slice literal：在数组或列表中不能使用 Cat 类作为 Animal 类 表5显示了当您尝试将 Animal 类型用作传统面向对象方式的基类时，Go 语言中发生的情况。 编译器非常清楚 Dog 和 Cat 类不能用作Animal类。 在这种情况下，Animal 类型和类型层次结构的使用并没有为我们提供任何实际价值。 我认为它正在引领我们走上一条不可读，不简单，适应性不强的代码之路。 第二部分在 Go 语言中编码时，尽量避免使用这些类型层次结构来促进共同状态的思想，并考虑共同行为。 如果我们考虑他们展示的共同行为，我们可以将一组狗和猫的值分组。 在这种情况下，Speak 有一个共同的行为。 让我们看看这段代码的另一个实现，它关注行为。 https://play.golang.org/p/6aLyTOTIj_ 表 6：1234567891001 package main0203 import &quot;fmt&quot;0405 // 如果他们想成为这个群体的一部分，06 // 扬声器为所有具体类型提供了一个共同的行为，07 // 这是这些具体类型的约定。08 type Speaker interface &#123;09 Speak()10 &#125; 新程序从表6开始，我们在第08行添加了一个名为 Speaker 的新类型。这不是我们之前声明的结构体类型的具体类型。 这是一种接口类型，它声明了一个行为约定，它允许我们对一组实现 Speak 方法的不同具体类型进行分组和处理。 表 7：12345678910111213141516171819202122232425262728293031323312 // Dog 结构体包含 Dog 需要的一切13 type Dog struct &#123;14 Name string15 IsMammal bool16 PackFactor int17 &#125;1819 // Speak 知道如何像狗一样叫20 // 这使得 Dog 现在成为了解如何说话的一组具体类型的一部分。2122 func (d Dog) Speak() &#123;23 fmt.Println(&quot;Woof!&quot;,24 &quot;My name is&quot;, d.Name,25 &quot;, it is&quot;, d.IsMammal,26 &quot;I am a mammal with a pack factor of&quot;, d.PackFactor)27 &#125;2829 // Cat 结构体包含 Cat 需要的一切30 type Cat struct &#123;31 Name string32 IsMammal bool33 ClimbFactor int34 &#125;3536 // Speak 知道怎样像猫一样叫37 // 这使得 Cat 现在成为了解如何说话的一组具体类型的一部分。3839 func (c Cat) Speak() &#123;40 fmt.Println(&quot;Meow!&quot;,41 &quot;My name is&quot;, c.Name,42 &quot;, it is&quot;, c.IsMammal,43 &quot;I am a mammal with a climb factor of&quot;, c.ClimbFactor)44 &#125; 在表7中，我们再次声明了具体类型的狗和猫。 此代码删除Animal类型并将这些公共字段直接复制到 Dog 和 Cat 中。 我们为什么那么做？ Animal 类型提供了可重用状态的抽象层。 该程序从不需要创建或仅使用 Animal 类型的值。 Animal 类型的 Speak 方法的实现是一种概括。 以下是有关声明类型的一些指导原则 声明类型表示新的或独特的事物。 验证是否自己创建或使用任何类型的值。 嵌入类型以重用您需要满足的现有行为。 作为现有类型的别名或抽象的问题类型。 其唯一目的是分享共同状态的问题类型。 让我们现在来看一下主函数 main 表 8：12345678910111213141516171819202122232425262746 func main() &#123;4748 // 创建一个知道如何说话的动物列表49 speakers := []Speaker&#123;5051 // 通过初始化其 Animal 部分，然后初始化其特定的 Dog 属性来创建一个52 // Dog。53 Dog&#123;54 Name: &quot;Fido&quot;,55 IsMammal: true,56 PackFactor: 5,57 &#125;,5859 // 通过初始化其 Animal 部分，然后初始化其特定的 Dog 属性来创建60 // 一个Cat61 Cat&#123;62 Name: &quot;Milo&quot;,63 IsMammal: true,64 ClimbFactor: 4,65 &#125;,66 &#125;6768 // 让Animal叫69 for _, spkr := range speakers &#123;70 spkr.Speak()71 &#125;72 &#125; 在表8的第49行，我们创建了一个 Speaker 接口值列表，以便在其常见行为下将 Dog 和 Cat 值组合在一起。 我们在第53行创建了 Dog 类型的值，在第61行创建了 Cat 类型的值。最后在第69-71行，我们迭代了 Speaker 接口值的列表并让 Dog 和 Cat 说话。 关于我们所做的改变的一些最终想法： 我们不需要基类或类型层次结构来将具体类型值组合在一起。 接口允许我们创建一个不同具体类型值的切片，并通过它们的共同行为来处理这些值。 我们通过不声明一个从未被程序单独使用过的类型，来消除类型污染。 总结Go 语言中的组合还有很多，但这是对使用类型层次结构的问题的初步理解。 每条规则总是有例外情况，但请务必遵循这些指导原则，直到您足够了解做出异常的权衡。 要了解有关此文章所涉及的构图和其他主题的更多信息，请查看以下其他博文： Exported/Unexported Identifiers In Go Methods Interfaces And Embedded Types Object Oriented Mechanics In Go Composition With Go 鸣谢以下是社区的一些朋友，我想感谢他们花时间审阅帖子并提供反馈。 Daniel Vaughan, Ted Young, Antonio Troina, Adam Straughan, Kaveh Shahbazian, Daniel Whitenack, Todd Rafferty via: https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html 作者：William Kennedy 译者：Jasonjiang27 校对：校对者ID 本文由 GCTT 原创编译，Go 中文网 荣誉推出","categories":[{"name":"cate","slug":"cate","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/categories/cate/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/tags/golang/"}]},{"title":"My New Post","slug":"My-New-Post","date":"2018-11-12T15:53:23.000Z","updated":"2018-11-13T13:55:57.039Z","comments":true,"path":"2018/11/12/My-New-Post/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/11/12/My-New-Post/","excerpt":"","text":"很高兴学会了自己搭建博客，以后学会积累，学会分享，路漫漫其修远兮，吾将上下而求索~ 相信自己一定可以成功！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-12T14:52:20.970Z","updated":"2018-11-12T14:52:20.970Z","comments":true,"path":"2018/11/12/hello-world/","link":"","permalink":"https://Jasonjiang27.github.io/Jasonjiang27.github.io/2018/11/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}